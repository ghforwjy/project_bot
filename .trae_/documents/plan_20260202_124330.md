## 问题分析

### 当前错误行为
1. 用户发送消息A，LLM开始处理
2. 用户发送消息B（打断）
3. LLM完成消息A的响应，发送到前端
4. 前端错误地将消息A的内容和消息B的内容混合显示

### 期望行为
1. 用户发送消息A，LLM开始处理
2. 用户发送消息B（打断）
3. 后端立即取消消息A的处理
4. LLM只处理消息B，返回响应
5. 前端只显示消息B的响应

## 技术方案

### 1. 前端：请求中断机制

```typescript
// ChatPanel.tsx
const abortControllerRef = useRef<AbortController | null>(null)

const handleSend = async () => {
  // 如果有正在进行的请求，取消它
  if (abortControllerRef.current) {
    abortControllerRef.current.abort()
  }
  
  // 创建新的AbortController
  abortControllerRef.current = new AbortController()
  
  // 发送请求时带上signal
  const response = await fetch('/api/v1/chat/messages', {
    method: 'POST',
    body: JSON.stringify({ message: inputValue, session_id: sessionId }),
    signal: abortControllerRef.current.signal
  })
}
```

### 2. 后端：支持请求中断

```python
# main.py 或 chat.py
from fastapi import Request
from starlette.concurrency import run_in_threadpool

@router.post("/chat/messages")
async def send_message(message: ChatMessageCreate, request: Request):
    """发送消息，支持中断"""
    
    # 检查请求是否被中断
    if await request.is_disconnected():
        raise HTTPException(status_code=499, detail="Client disconnected")
    
    # 在执行LLM调用时定期检查连接状态
    try:
        response = await llm_provider.chat(messages, config=request.state.abort_event)
    except asyncio.CancelledError:
        raise HTTPException(status_code=499, detail="Request cancelled")
```

### 3. 会话状态跟踪

```python
# 会话状态管理
class SessionState:
    def __init__(self):
        self.current_request_id = None
        self.messages = []
    
    def start_request(self, request_id):
        self.current_request_id = request_id
    
    def cancel_request(self, session_id):
        if self.current_request_id:
            # 取消之前的请求
            self.current_request_id = None
    
    def is_request_active(self, request_id):
        return self.current_request_id == request_id

session_states = {}

@router.post("/chat/messages")
async def send_message(message: ChatMessageCreate, session_id: str):
    # 检查是否有活跃请求需要取消
    if session_id in session_states:
        session_states[session_id].cancel_request()
    
    # 创建新的请求ID
    request_id = str(uuid.uuid4())
    session_states[session_id] = SessionState()
    session_states[session_id].start_request(request_id)
    
    try:
        # 执行LLM调用
        response = await process_message(message, request_id)
        
        # 成功后清除请求状态
        session_states[session_id].current_request_id = None
        
        return response
    except asyncio.CancelledError:
        # 请求被取消
        return {"cancelled": True}
```

### 4. 前端消息管理

```typescript
// chatStore.ts
interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  content_blocks?: ContentBlock[]
  request_id?: string  // 关联的请求ID
}

const addMessage = (message: Message) => {
  // 如果消息的request_id不是当前活跃的，清空之前assistant的消息
  if (message.role === 'assistant') {
    const currentActiveRequest = getActiveRequestId()
    if (message.request_id !== currentActiveRequest) {
      // 清除所有assistant消息（它们是过时的）
      state.messages = state.messages.filter(m => m.role === 'user')
    }
  }
  state.messages.push(message)
}
```

## 流程图

```
用户发送消息B
     ↓
前端：取消之前的请求（abort）
     ↓
后端：标记会话状态为新请求
     ↓
后端：处理消息B
     ↓
前端：只显示消息B的响应
     ↓
完成
```

## 修改文件

1. `frontend/src/components/chat/ChatPanel.tsx`
   - 添加AbortController管理
   - 发送新消息前取消之前的请求

2. `frontend/src/store/chatStore.ts`
   - 添加request_id跟踪
   - 新消息到来时清除过时响应

3. `backend/api/chat.py`
   - 添加会话状态管理
   - 支持请求中断检查

4. 新建 `backend/core/session_manager.py`
   - 管理会话状态
   - 跟踪活跃请求