## 问题分析

### 当前错误（从截图看）
LLM返回了两个JSON块和对应的解释：
1. "好的，我现在创建'信创工作大类'..." + create_category JSON
2. "好的，我把'信创工作'纳入...'了。" + assign_category JSON

但当前代码把：
- 所有JSON放在一起 → content
- 所有自然语言放在一起 → analysis

导致显示错乱。

### 正确做法
每个JSON块应该和它**紧邻的解释**在一起：
- 解释1 + JSON1 → 一条消息
- 解释2 + JSON2 → 另一条消息

但当前设计不支持一条消息包含多个(JSON+解释)对。

## 解决方案

### 方案A：修改数据结构
一条消息可以包含多个(analysis, content)对：
```python
{
  "message_id": 1,
  "content_blocks": [
    {"analysis": "解释1", "content": "JSON1"},
    {"analysis": "解释2", "content": "JSON2"},
  ]
}
```

### 方案B：限制LLM返回
每轮对话只返回**一个JSON指令**，不要多个。

### 方案C：智能关联
检测JSON块前后的自然语言，将相关的自然语言和JSON关联：
- "创建"开头的自然语言 + create_category JSON
- "纳入"开头的自然语言 + assign_category JSON

### 推荐：方案A + 方案B

1. 修改后端数据结构，支持多条目
2. 修改系统提示词，限制每轮只返回一个JSON
3. 如果LLM返回多个JSON，拆分成多条消息

## 修改内容

### 1. 修改Conversation实体
添加content_blocks字段（JSON数组）：
```python
content_blocks = Column(Text, nullable=True)  # JSON数组，每个元素包含analysis和content
```

### 2. 修改split_ai_content函数
支持多个(JSON+解释)对：
```python
def split_ai_content(ai_content: str) -> list:
    """
    解析AI回复，返回多个(analysis, content)对
    
    Returns:
        list: [{"analysis": "解释", "content": "JSON"}, ...]
    """
    # 查找所有JSON块
    json_matches = list(re.finditer(r'```json\n(.*?)\n```', ai_content, re.DOTALL))
    
    if not json_matches:
        return [{"analysis": "", "content": ai_content}]
    
    blocks = []
    for i, match in enumerate(json_matches):
        json_content = match.group(1).strip()
        
        # 获取JSON之前的自然语言
        start = match.start()
        prev_end = json_matches[i-1].end() if i > 0 else 0
        analysis = ai_content[prev_end:start].strip()
        
        # 获取JSON之后的内容（直到下一个JSON或结束）
        next_start = match.end()
        next_end = json_matches[i+1].start() if i+1 < len(json_matches) else len(ai_content)
        after_content = ai_content[next_start:next_end].strip()
        
        # 如果after_content很短（没有新JSON的独立解释），可以合并到analysis
        if after_content and not re.search(r'```json', after_content):
            if analysis:
                analysis = f"{analysis}\n{after_content}"
            else:
                analysis = after_content
        
        blocks.append({
            "analysis": analysis,
            "content": f"```json\n{json_content}\n```"
        })
    
    return blocks
```

### 3. 修改前端显示
遍历content_blocks数组，逐个显示：
```jsx
{message.content_blocks.map((block, index) => (
  <div className="message-block">
    <div className="content">{block.content}</div>
    {block.analysis && <AnalysisCollapse analysisText={block.analysis} />}
  </div>
))}
```

### 4. 修改系统提示词
添加规则：
```
每轮对话只返回一个JSON指令，不要返回多个。
```

## 测试用例

测试多JSON场景：
```
输入：
好的，我先创建类别。
```json
{"intent":"create_category","data":{"name":"A"}}
```
然后把项目纳入类别。
```json
{"intent":"assign_category","data":{"project":"P","category":"A"}}
```

期望输出（2个block）：
Block1: analysis="好的，我先创建类别。" content=create_category JSON
Block2: analysis="然后把项目纳入类别。" content=assign_category JSON
```