# 甘特图Tooltip数据计算问题改进计划

## 数据结构分析

### 1. 问题字段映射表

| 问题字段 | 类型 | 预期含义 | 实际情况 | 修正方案 |
|---------|------|----------|----------|----------|
| `task.status` | string | 任务状态 | 不存在 | 使用 `task.custom_class` 解析 |
| `task.planned_start_date` | string | 计划开始日期 | 不存在 | 使用 `task.start` |
| `task.planned_end_date` | string | 计划结束日期 | 不存在 | 使用 `task.end` |
| `task.actual_start_date` | string | 实际开始日期 | 不存在 | 基于 `task.startTimeType` 解析 |
| `task.actual_end_date` | string | 实际结束日期 | 不存在 | 基于 `task.endTimeType` 解析 |

### 2. 修正后的字段映射表

| 计算需要的字段 | 类型 | 来源字段 | 解析方法 |
|---------------|------|----------|----------|
| 任务状态 | string | `task.custom_class` | `getStatusFromCustomClass()` 函数 |
| 计划开始日期 | string | `task.start` | 直接使用 |
| 计划结束日期 | string | `task.end` | 直接使用 |
| 实际开始日期 | string | `task.start` + `task.startTimeType` | 当 `startTimeType` 为 "actual" 时使用 |
| 实际结束日期 | string | `task.end` + `task.endTimeType` | 当 `endTimeType` 为 "actual" 时使用 |
| 任务进度 | number | `task.progress` | 直接使用 |

## 问题分析

### 根本原因
**数据字段不匹配**：前端Tooltip计算时使用的字段名与后端返回的数据结构不一致，导致所有计算返回0。

### 具体问题点
1. **任务状态过滤失败**：使用 `task.status` 字段，实际应使用 `task.custom_class`
2. **计划天数计算失败**：使用 `task.planned_start_date` 和 `task.planned_end_date`，实际应使用 `task.start` 和 `task.end`
3. **实际天数计算失败**：使用 `task.actual_start_date` 和 `task.actual_end_date`，这些字段不存在
4. **所有任务被过滤**：三个过滤条件都返回空数组，导致总任务数为0

## 改进方案

### 核心原则
- **保持现有架构**：不修改后端数据结构，只调整前端Tooltip计算逻辑
- **运用现有数据**：基于后端返回的实际数据结构进行计算
- **保持一致性**：与甘特图渲染逻辑保持一致
- **最小化修改**：仅限于Tooltip相关数据的获取和计算逻辑

### 具体改进措施

#### 1. 添加任务状态解析函数
- **函数名**：`getStatusFromCustomClass(customClass: string): string`
- **功能**：将CSS类名转换为任务状态
- **映射关系**：
  - 'bar-active' → 'active'
  - 'bar-pending' → 'pending'
  - 'bar-completed' → 'completed'
  - 'bar-delayed' → 'delayed'
  - 'bar-cancelled' → 'cancelled'

#### 2. 修正任务状态分布计算
- **修改逻辑**：使用 `getStatusFromCustomClass(task.custom_class)` 解析任务状态
- **具体实现**：
  ```typescript
  const completedTasks = project.tasks.filter(task => 
    getStatusFromCustomClass(task.custom_class) === 'completed'
  ).length;
  ```

#### 3. 修正计划天数计算
- **修改逻辑**：使用 `task.start` 和 `task.end` 字段
- **具体实现**：
  ```typescript
  if (task.start && task.end) {
    const plannedStart = new Date(task.start);
    const plannedEnd = new Date(task.end);
    const plannedDays = (plannedEnd.getTime() - plannedStart.getTime()) / (1000 * 60 * 60 * 24);
    if (plannedDays > 0) {
      totalPlannedDays += plannedDays;
    }
  }
  ```

#### 4. 修正实际天数计算
- **修改逻辑**：基于任务状态和时间类型计算
- **具体实现**：
  ```typescript
  if (task.start) {
    const actualStart = new Date(task.start);
    const taskStatus = getStatusFromCustomClass(task.custom_class);
    
    if (taskStatus === 'completed') {
      // 已完成任务：使用整个任务周期
      if (task.end) {
        const actualEnd = new Date(task.end);
        const actualDays = (actualEnd.getTime() - actualStart.getTime()) / (1000 * 60 * 60 * 24);
        if (actualDays > 0) {
          totalActualDays += actualDays;
        }
      }
    } else if (taskStatus === 'active' || taskStatus === 'delayed') {
      // 进行中或延迟任务：使用从开始到当前的时间
      const today = new Date();
      const actualDays = (today.getTime() - actualStart.getTime()) / (1000 * 60 * 60 * 24);
      if (actualDays > 0) {
        totalActualDays += actualDays;
      }
    }
  }
  ```

#### 5. 添加数据验证和容错处理
- **空值检查**：对所有字段访问添加空值检查
- **默认值处理**：当字段不存在时使用合理的默认值
- **边界情况**：处理无任务、时间字段缺失等情况

## 实施步骤

### 步骤1：添加任务状态解析函数
- 在 `GanttChart.tsx` 中添加 `getStatusFromCustomClass` 函数
- 实现CSS类名到任务状态的映射

### 步骤2：修正Tooltip数据计算逻辑
- 修改任务状态分布计算，使用解析后的任务状态
- 修改计划天数计算，使用 `task.start` 和 `task.end` 字段
- 修改实际天数计算，基于任务状态和时间正确计算

### 步骤3：添加数据验证和容错处理
- 为所有字段访问添加空值检查
- 添加合理的默认值处理
- 确保在字段缺失时仍能正常计算

### 步骤4：测试验证
- 验证Tooltip显示的数据与甘特图一致
- 验证不同任务状态的计算结果正确
- 验证无任务时的显示逻辑正确
- 验证修改不影响其他甘特图功能

## 预期效果

修改后，Tooltip应显示与甘特图一致的数据：
- **任务状态分布**：正确显示已完成、进行中、未开始的任务数量
- **计划总天数**：基于任务的start和end字段正确计算
- **实际已进行天数**：基于任务状态和时间正确计算
- **进度计算公式**：保持不变，(实际已进行天数 / 计划总天数) × 100%
- **时间进度对比**：正确计算时间进度与实际进度
- **进度状态评估**：正确评估进度是否正常

## 技术实现要点

1. **保持代码结构清晰**：添加独立的辅助函数，避免逻辑混乱
2. **与现有逻辑一致**：确保Tooltip计算逻辑与甘特图渲染逻辑使用相同的数据获取方式
3. **充分的注释**：为关键计算步骤添加注释，提高可维护性
4. **性能优化**：避免重复计算，使用缓存机制
5. **错误处理**：添加try-catch块，确保计算失败时不影响其他功能

## 风险评估

### 低风险
- **修改范围小**：仅限于Tooltip相关计算逻辑
- **不影响核心功能**：甘特图渲染逻辑保持不变
- **向后兼容**：即使后端数据结构变化，也能通过调整映射关系适配

### 注意事项
- **数据字段验证**：确保所有使用的字段都存在，避免undefined错误
- **时间格式处理**：确保时间字符串格式正确，避免日期解析错误
- **边界情况**：处理任务数量为0、时间字段缺失等边界情况
- **性能考虑**：对于大量任务的项目，确保计算性能良好