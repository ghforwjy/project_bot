## 详细问题分析和修复计划

### 问题1：WebSocket连接方式不正确

**当前代码（错误）：**
```python
# 使用 httpx 的 ws_connect
async with httpx.AsyncClient() as client:
    async with client.ws_connect(ws_url, headers=headers) as ws:
        message = await ws.receive_message(timeout=0.1)
```

**错误原因：**
1. `httpx` 的 WebSocket 支持与豆包API协议不兼容
2. `receive_message()` 返回的消息类型不匹配
3. 豆包API使用标准WebSocket二进制帧

**正确的实现：**
```python
# 使用 aiohttp 的 ws_connect
async with aiohttp.ClientSession() as session:
    async with session.ws_connect(ws_url, headers=headers) as ws:
        async for msg in ws:
            if msg.type == aiohttp.WSMsgType.BINARY:
                # 处理二进制数据
```

---

### 问题2：消息格式不正确

**当前代码（错误）：**
```python
header[0] = (0b0001 << 4) | 0b0001
header[1] = (0b0001 << 4) | 0b0001
```

**正确的消息头部结构（4字节）：**
- byte 0: [version(4bits) | header_size(4bits)]
- byte 1: [message_type(4bits) | flags(4bits)]
- byte 2: [serialization(4bits) | compression(4bits)]
- byte 3: reserved

**初始化请求：**
- message_type = 0b0001 (client full request)
- flags = 0b0001 (positive sequence)
- serialization = 0b0001 (JSON)
- compression = 0b0001 (gzip)

**音频数据请求：**
- message_type = 0b0010 (client audio only)
- flags = 0b0001 (positive) 或 0b0011 (negative for last packet)
- serialization = 0b0000 (none)
- compression = 0b0001 (gzip)

**正确的实现：**
```python
def _build_init_request(self, seq: int, init_request: dict) -> bytes:
    payload_bytes = json.dumps(init_request).encode('utf-8')
    compressed_payload = gzip.compress(payload_bytes)
    
    header = bytearray()
    header.append((0b0001 << 4) | 0b0001)  # version 1, header size 1
    header.append((0b0001 << 4) | 0b0001)  # full client request, with sequence
    header.append((0b0001 << 4) | 0b0001)  # JSON, gzip
    header.append(0x00)
    
    message = bytearray(header)
    message.extend(struct.pack('>i', seq))  # 4字节序列号，大端序
    message.extend(struct.pack('>I', len(compressed_payload)))
    message.extend(compressed_payload)
    
    return bytes(message)
```

---

### 问题3：音频数据格式不正确

**当前代码（错误）：**
```python
# 直接分割原始音频数据发送
segments = self._split_audio(content, segment_size)
for segment in segments:
    audio_message = self._build_audio_request(i + 1, segment, is_last)
```

**错误原因：**
1. 直接发送原始PCM数据，没有WAV头部
2. 豆包API需要完整的WAV格式数据

**正确的实现：**
```python
# 先将音频包装成WAV格式
wav_data = self._add_wav_header(content)
segments = self._split_audio(wav_data, segment_size)

for i, segment in enumerate(segments):
    # 压缩音频段
    compressed = gzip.compress(segment)
    # 构建消息并发送
```

---

### 问题4：响应处理不正确

**当前代码（错误）：**
```python
async def _process_response(self, data: bytes) -> dict:
    version = (data[0] >> 4) & 0x0F
    header_size = data[0] & 0x0F
    # 简化处理...
```

**正确的实现：**
```python
async def _process_response(self, data: bytes) -> dict:
    # 解析头部
    version = (data[0] >> 4) & 0x0F
    header_size = data[0] & 0x0F
    message_type = (data[1] >> 4) & 0x0F
    flags = data[1] & 0x0F
    
    # 计算payload起始位置
    payload_start = header_size * 4
    if flags & 0x01:  # 有序列号
        payload_start += 4
    if flags & 0x04:  # 有事件
        payload_start += 4
    
    # 处理不同类型的消息
    if message_type == 0b1001:  # server full response
        payload_size = int.from_bytes(data[payload_start:payload_start+4], byteorder='big')
        payload = data[payload_start+4:payload_start+4+payload_size]
        
        # 解压缩并解析JSON
        if compression == 0b0001:
            payload = gzip.decompress(payload)
        response_data = json.loads(payload.decode('utf-8'))
        
        return {
            'success': True,
            'text': response_data.get('result', {}).get('text', ''),
            'is_final': response_data.get('is_last_package', False)
        }
    elif message_type == 0b1111:  # error response
        # 处理错误...
```

---

### 问题5：前端音频格式问题

**当前代码：**
```typescript
const mediaRecorder = new MediaRecorder(stream, { 
    mimeType: 'audio/webm'
})
```

**问题：** 前端使用 webm 格式，但豆包API需要 WAV 格式

**解决方案：** 后端将 webm 转换为 wav
```python
# 在 voice_api.py 中
subprocess.run([
    'ffmpeg', '-i', temp_webm_path,
    '-acodec', 'pcm_s16le', '-ac', '1', '-ar', '16000',
    temp_wav_path
])
```

---

## 修复步骤

### 阶段1：修复 `doubao_voice_integration.py`
1. 导入 `aiohttp` 替换 `httpx`
2. 重写 `_build_init_request` 方法
3. 重写 `_build_audio_request` 方法
4. 重写 `transcribe_streaming` 方法
5. 重写 `_process_response` 方法
6. 添加 `_add_wav_header` 方法

### 阶段2：修复 `voice_api.py`
1. 修改 `/voice/stream` WebSocket 端点
2. 完整接收音频数据
3. 将 webm 转换为 wav
4. 调用识别方法
5. 返回识别结果

### 阶段3：测试验证
1. 测试后端 API
2. 测试前端语音输入
3. 验证识别结果显示

---

## 修改范围
- `backend/voice/doubao_voice_integration.py`
- `backend/voice/voice_api.py`

不影响其他功能模块。